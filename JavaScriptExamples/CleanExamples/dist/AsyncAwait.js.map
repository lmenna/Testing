{"version":3,"sources":["../src/AsyncAwait.js"],"names":["myPromiseStillBlocking","msg","Promise","resolve","reject","console","log","variableBlockingCode","then","result","myPromiseInParallel","myPromiseError","codeBlocker","codeNonBlocker","v","maxCount","x","Math","random"],"mappings":";;;;;;;;;;;AACA;;;;;;AAMA,IAAIA,sBAAsB,GAAG,SAAzBA,sBAAyB,CAACC,GAAD;AAAA,SAC3B,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AAC/B;AACA;AACAC,IAAAA,OAAO,CAACC,GAAR,+BAAmCL,GAAnC;AACAM,IAAAA,oBAAoB,CAAC,QAAD,CAApB,CACA;AADA,KAECC,IAFD,CAEM,UAASC,MAAT,EAAgB;AACpBJ,MAAAA,OAAO,CAACC,GAAR,CAAY,UAAZ;AACAH,MAAAA,OAAO,CAACM,MAAD,CAAP;AACA,aAAOA,MAAP;AACD,KAND;AAOD,GAXD,CAD2B;AAAA,CAA7B;AAeA;;;;;;;AAGA,IAAIC,mBAAmB,GAAG,SAAtBA,mBAAsB,CAACT,GAAD;AAAA,SACvBC,OAAO,CAACC,OAAR,GAAkBK,IAAlB,CAAuB,UAAAP,GAAG,EAAI;AAC7B;AACA;AACAI,IAAAA,OAAO,CAACC,GAAR,+BAAmCL,GAAnC;AACAM,IAAAA,oBAAoB,CAAC,QAAD,CAApB,CACA;AADA,KAECC,IAFD,CAEM,UAASC,MAAT,EAAgB;AACpBJ,MAAAA,OAAO,CAACC,GAAR,CAAY,UAAZ;AACC,aAAOG,MAAP;AACF,KALD;AAMD,GAVA,CADuB;AAAA,CAA1B;;;;AAcA,IAAIE,cAAc,GAAG,SAAjBA,cAAiB,CAACV,GAAD;AAAA,SACnB,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AAC/B;AACA;AACAC,IAAAA,OAAO,CAACC,GAAR,+BAAmCL,GAAnC;AACAM,IAAAA,oBAAoB,CAAC,OAAD,CAApB,CACA;AADA,KAECC,IAFD,CAEM,UAASC,MAAT,EAAgB;AACpBJ,MAAAA,OAAO,CAACC,GAAR,CAAY,UAAZ;AACAF,MAAAA,MAAM,CAAC,gBAAD,CAAN;AACA,aAAOK,MAAP;AACD,KAND;AAOD,GAXD,CADmB;AAAA,CAArB;;;;AAeA,IAAMG,WAAW,GAAG,SAAdA,WAAc,CAACX,GAAD,EAAS;AAC3B,SAAO,IAAIC,OAAJ;AAAA;AAAA;AAAA;AAAA;AAAA,4BAAY,iBAAOC,OAAP,EAAgBC,MAAhB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qBACXG,oBAAoB,CAAC,OAAD,CADT;;AAAA;AAEjBJ,cAAAA,OAAO,CAACF,GAAD,CAAP;;AAFiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAZ;;AAAA;AAAA;AAAA;AAAA,MAAP;AAID,CALD;;;;AAOA,IAAMY,cAAc,GAAG,SAAjBA,cAAiB,CAACZ,GAAD,EAAS;AAC9B,SAAOC,OAAO,CAACC,OAAR,GAAkBK,IAAlB;AAAA;AAAA;AAAA;AAAA;AAAA,4BAAuB,kBAAOM,CAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qBACtBP,oBAAoB,CAAC,OAAD,CADE;;AAAA;AAAA,gDAErBN,GAFqB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAvB;;AAAA;AAAA;AAAA;AAAA,MAAP;AAID,CALD;;;;AAQA,IAAIM,oBAAoB,GAAG,SAAvBA,oBAAuB,CAACQ,QAAD;AAAA,SACzB,IAAIb,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AAC/B,QAAIY,CAAC,GAAG,CAAR;;AACA,WAAMA,CAAC,GAAGD,QAAV,EAAoB;AAClBC,MAAAA,CAAC,IAAIC,IAAI,CAACC,MAAL,EAAL;AACD;;AACDf,IAAAA,OAAO,CAACY,QAAD,CAAP;AACD,GAND,CADyB;AAAA,CAA3B","sourcesContent":["\n/* myPromiseStillBlocking\n * desc: This function shows a valid usage of using a promise to run a task and return\n *       the result later by resolving the promise. result = await myPromiseStillBlocking works fine.\n *       But there is a problem.  If myPromiseStillBlocking is called multiple time and a await Promise.all\n *       is each call will still run sequentially.\n */ \nvar myPromiseStillBlocking = (msg) => (\n  new Promise((resolve, reject) => {\n    //do something, fetch something....\n    //you guessed it, mongo queries go here.\n    console.log(`Begin long query... ${msg}`);\n    variableBlockingCode(10000000)\n    //I can continue to process my result inside my promise\n    .then(function(result){\n      console.log(\"In .then\")\n      resolve(result);\n      return result;\n    })\n  })\n);\n\n/* myPromiseInParallel\n * desc: Same as the blocking version above, but this version can be run in parallel using await Promise.all\n */ \nvar myPromiseInParallel = (msg) => (\n   Promise.resolve().then(msg => {\n    //do something, fetch something....\n    //you guessed it, mongo queries go here.\n    console.log(`Begin long query... ${msg}`);\n    variableBlockingCode(10000000)\n    //I can continue to process my result inside my promise\n    .then(function(result){\n      console.log(\"In .then\")\n       return result;\n    })\n  })\n);\n\nvar myPromiseError = (msg) => (\n  new Promise((resolve, reject) => {\n    //do something, fetch something....\n    //you guessed it, mongo queries go here.\n    console.log(`Begin long query... ${msg}`);\n    variableBlockingCode(1000000)\n    //I can continue to process my result inside my promise\n    .then(function(result){\n      console.log(\"In .then\")\n      reject(\"Something Bad!\");\n      return result;\n    })\n  })\n);\n\nconst codeBlocker = (msg) => {\n  return new Promise(async (resolve, reject) => {\n    await variableBlockingCode(5000000);\n    resolve(msg);\n  });\n}\n\nconst codeNonBlocker = (msg) => {\n  return Promise.resolve().then(async (v) => {\n    await variableBlockingCode(5000000);\n    return(msg);\n  });\n}\n\n\nvar variableBlockingCode = (maxCount) => (\n  new Promise((resolve, reject) => {\n    let x = 0;\n    while(x < maxCount) {\n      x += Math.random();\n    }\n    resolve(maxCount);\n  })\n);\n\nexport { codeBlocker, codeNonBlocker, myPromiseStillBlocking, myPromiseInParallel, myPromiseError }"],"file":"AsyncAwait.js"}