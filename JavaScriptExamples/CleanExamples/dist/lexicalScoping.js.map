{"version":3,"sources":["../src/lexicalScoping.js"],"names":["LexicalScoping","self","aVar","getVarArrow","getVar","getVarFromHidden","getVarHidden","getVarArrowHidden","getVarFromHiddenArrow","simpleHoistingExample"],"mappings":";;;;;;;;AAAA;;;;AAIA;;;;;;;;AAQA,SAASA,cAAT,GAA0B;AAAA;;AAExB,MAAIC,IAAI,GAAG,IAAX,CAFwB,CAEP;;AACjB,OAAKC,IAAL,GAAY,CAAZ,CAHwB,CAKxB;;AACA,OAAKC,WAAL,GAAmB;AAAA,WAAM,KAAI,CAACD,IAAX;AAAA,GAAnB,CANwB,CAQxB;;;AACA,OAAKE,MAAL,GAAc,YAAW;AACvB,SAAKF,IAAL,GAAY,CAAZ;AACA,SAAKA,IAAL;AACA,WAAO,KAAKA,IAAZ;AACD,GAJD,CATwB,CAexB;;;AACA,OAAKG,gBAAL,GAAwB,YAAW;AAC/B,WAAOC,YAAY,EAAnB;AACH,GAFD,CAhBwB,CAoBxB;;;AACA,MAAIC,iBAAiB,GAAG,SAApBA,iBAAoB;AAAA,WAAM,KAAI,CAACL,IAAX;AAAA,GAAxB;;AAEA,OAAKM,qBAAL,GAA6B,YAAW;AACpC,WAAOD,iBAAiB,EAAxB;AACH,GAFD,CAvBwB,CA2BxB;;;AACA,WAASD,YAAT,GAAwB;AACtB;AACA,WAAOL,IAAI,CAACC,IAAZ;AACD;AAEF;AAED;;;;;;AAIA,SAASO,qBAAT,GAAiC;AAE/BP,EAAAA,IAAI,GAAG,CAAP,CAF+B,CAErB;;AACV,SAAOA,IAAP,CAH+B,CAGhB;;AACf,MAAIA,IAAI,GAAG,CAAX,CAJ+B,CAIjB;AACf","sourcesContent":["/* lexicalScoping.js\n * desc: Example of how lexical scoping of variables for arrow functions differs from regular functions.\n */\n\n/* LexicalScoping\n * desc: This is a JavaScript function that behaves like an object.  Sometimes this is called\n *       a constructor function.\n *       It declares and sets member variables and member fucntions using the \"this\" keyword.\n *       You don't call this function, rather you \"new\" it.  Like this,\n *       let l = new LexicalScoping();\n *       l.checkLexicalScope();\n */\nfunction LexicalScoping() {\n\n  var self = this; // Allows the hidden function to access the aVar.\n  this.aVar = 1;\n\n  // \"this.\" arrow functions have access to \"this\" and are visible from outside the function LexicalScoping()\n  this.getVarArrow = () => this.aVar;\n\n  // \"this.\" functions have access to \"this\" and are visible from outside the function LexicalScoping()\n  this.getVar = function() {\n    this.aVar = 2;\n    this.aVar++;\n    return(this.aVar);\n  }\n\n  // \"this.\" functions have access to \"this\" and are visible from outside the function LexicalScoping()\n  this.getVarFromHidden = function() {\n      return(getVarHidden());\n  }\n\n  // Note: Inner arrow functions have access to \"this\".  They are NOT visible outside of the LexicalScoping() function.\n  var getVarArrowHidden = () => this.aVar;\n\n  this.getVarFromHiddenArrow = function() {\n      return(getVarArrowHidden());\n  }\n\n  // Inner functions don't have access to this.\n  function getVarHidden() {\n    // Can't use this. here.  Need to use the saved \"this\" in \"self\".\n    return(self.aVar);\n  }\n\n}\n\n/* simpleHoistingExample\n * desc: Shows how the lexical parsing of the JavaScript during compilation allows aVar to be accessed\n *       prior to its declarations and definition.\n */\nfunction simpleHoistingExample() {\n\n  aVar = 1; // This looks weird, but it works. The aVar declaration at the end applies to the whole scope!\n  return(aVar);  // At this point aVar is exist and has a value.\n  var aVar = 3; // Now we declare and set aVar's value, but all the action happened above.\n}\n\nexport {LexicalScoping, simpleHoistingExample};\n"],"file":"lexicalScoping.js"}